#ifndef __FixedMatrix__
#define __FixedMatrix__
/*
FixedMatrix.h. Fixed point matrix class for microcontrollers.

Copyright (C) 2005-2006  Matthew Chave mattchave@hotmail.com

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/

#include "Fixed.h"
#include "FixedVector.h"

//class Quaternion;
// #include "Quaternion.h"

/*!\brief A 3X3 matrix of Fixed16 objects. For calculations using rotation matricies
*/
class FixedMatrix
{
public:
	FixedMatrix()
		: 	m11(0),m12(0),m13(0),
			m21(0),m22(0),m23(0),
			m31(0),m32(0),m33(0)
	{
	}

	FixedMatrix(const FixedMatrix& m)
		: 	m11(m.m11), m12(m.m12), m13(m.m13),
			m21(m.m21), m22(m.m22), m23(m.m23),
			m31(m.m31), m32(m.m32), m33(m.m33)
	{
	}

	FixedMatrix(const Fixed16& in_m11, const Fixed16& in_m12, const Fixed16& in_m13, 
			const Fixed16& in_m21, const Fixed16& in_m22, const Fixed16& in_m23,
			const Fixed16& in_m31, const Fixed16& in_m32, const Fixed16& in_m33)
		: 	m11(in_m11),m12(in_m12),m13(in_m13),
			m21(in_m21),m22(in_m22),m23(in_m23),
			m31(in_m31),m32(in_m32),m33(in_m33)
	{
	}
	
	//populates a matrix with the columb vectors v1, v2 and v3 along the matricies columbs
	FixedMatrix(const FixedVector& in_v1, const FixedVector& in_v2, const FixedVector& in_v3)
		: 	m11(in_v1.x),m12(in_v2.x),m13(in_v3.x),
			m21(in_v1.y),m22(in_v2.y),m23(in_v3.y),
			m31(in_v1.z),m32(in_v2.z),m33(in_v3.z)
	{
	}

	FixedMatrix(const Fixed32& in_m11, const Fixed32& in_m12, const Fixed32& in_m13, 
			const Fixed32& in_m21, const Fixed32& in_m22, const Fixed32& in_m23,
			const Fixed32& in_m31, const Fixed32& in_m32, const Fixed32& in_m33)
		: 	m11(in_m11),m12(in_m12),m13(in_m13),
			m21(in_m21),m22(in_m22),m23(in_m23),
			m31(in_m31),m32(in_m32),m33(in_m33)
	{
	}

	FixedMatrix(const f_int32& in_m11, const f_int32& in_m12, const f_int32& in_m13, 
			const f_int32& in_m21, const f_int32& in_m22, const f_int32& in_m23,
			const f_int32& in_m31, const f_int32& in_m32, const f_int32& in_m33)
		: 	m11(in_m11),m12(in_m12),m13(in_m13),
			m21(in_m21),m22(in_m22),m23(in_m23),
			m31(in_m31),m32(in_m32),m33(in_m33)
	{
	}
	
//	this is now a for rotating a vector using a rotation matrix, but probably not right yet
//	/*!\brief Rotate a vector using the Matrix m
//	*/
//	FixedVector Rotate3D(const FixedMatrix& m) const;

#ifdef IOSTREAMS
	friend std::ostream& operator<<(std::ostream& os, const FixedMatrix&);
	
	static bool testharness();
#endif
	
	Fixed16 m11,m12,m13, m21,m22,m23, m31,m32,m33;
};

FixedMatrix operator+(const FixedMatrix& a, const FixedMatrix& b);
FixedMatrix operator-(const FixedMatrix& a, const FixedMatrix& b);
FixedMatrix operator*(const FixedMatrix& a, const Fixed16& b);
FixedMatrix operator*(const Fixed16& b, const FixedMatrix& a);
FixedMatrix operator*(const FixedMatrix& a, const FixedMatrix& b);
FixedVector operator*(const FixedVector& a, const FixedMatrix& b);
FixedVector operator*(const FixedMatrix& b, const FixedVector& a);
FixedMatrix operator/(const FixedMatrix& a, const Fixed16& b);

/*!\brief returns the inner dot product for each of the rows of a and b (opposite to matlab which uses the columbs)
	same as the diagonal elements of (a*transpose(b))
*/
FixedVector dot(const FixedMatrix& a, const FixedMatrix& b);

/*!\brief returns the determinant of a matrix
	
*/
Fixed16 det(const FixedMatrix& a);

/*!\brief returns the inverse of a matrix
	
*/
FixedMatrix inv(const FixedMatrix& a);

/*!\brief returns the transpose of a matrix
	
*/
FixedMatrix trans(const FixedMatrix& a);

/*!\brief calculates the determinant of a 2x2 matrix
	M = 	[a b; c d]
	det(M) = a*d - c*b
*/
Fixed16 det2by2(const Fixed16& a, const Fixed16& b, const Fixed16& c, const Fixed16& d);

/*!\brief returns Cofactor Matrix
	The matrix with elements that are the cofactors, term-by-term, of a 3x3 matrix
*/
FixedMatrix cofact(const FixedMatrix& a);

/*!\brief returns rotation Matrix given three euler angles
	theta denotes a rotation about the x-axis, phi about y, and psi about z
*/
FixedMatrix getrotmat(Fixed16& theta, Fixed16& phi, Fixed16& psi);

/*!\brief returns a vector of three euler angles given a rotation matrix
	.x is a roll rotation
	.y is a rotation in elevation from the x-y plane
	.z is a rotation in direction about the z axis in the x-y plane
*/
FixedVector get_eulers(FixedMatrix& R);


// /*!\brief Vector cross product (a x b).
// */
// FixedVector cross(const FixedVector& a, const FixedVector& b);


#endif /* __FixedMatrix__ */
