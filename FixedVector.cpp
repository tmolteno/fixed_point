/*
FixedVector.cpp. Fixed point vector class for microcontrollers.

Copyright (C) 2005-2006  Tim Molteno tim@molteno.net

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/

#include "FixedVector.h"
#include "Quaternion.h"

#ifdef IOSTREAMS

bool FixedVector::testharness()
{
	FixedVector a(1,2,3);
	FixedVector b(3,4,5);
	
	cout << endl << "FixedVector TestHarness" << endl << endl;
	cout << "a " << a << endl;
	cout << "b " << b << endl;
	
	cout << "norm(a) " << norm(a) << endl;
	cout << "norm(a)*norm(a) " << norm(a)*norm(a) << endl;
	
	cout << "a-b " << (a - b) << endl;
	cout << "angle(a,a) " << angle(a,a)*57 << " degrees" << endl;
	cout << "angle(a,b) " << angle(a,b)*57 << " degrees" << endl;
	
	cout << "angle(b,a) " << angle(b,a)*57 << " degrees" << endl;

	cout << "UnitVector(cross(b,a)) " << UnitVector(cross(b,a)) << endl;
	
	
	//for (int i=0;i<1000;i++)
	{
		FixedVector mag_field(23,45,67);
		cout << "mag_field " << mag_field << endl;

		mag_field = mag_field / Fixed16(10);

		UnitVector u(mag_field);

		
		cout << "norm(mag_field) " << norm(mag_field) << endl;
	
		cout << "UnitVector(mag_field) " << UnitVector(mag_field) << endl;
		cout << "norm(UnitVector(mag_field)) " << norm(UnitVector(mag_field)) << endl;
	}
	cout << endl << "FixedVector TestHarness Complete" << endl << endl;
	return true;
}
#endif

#ifdef IOSTREAMS
std::ostream& operator<<(std::ostream& os, const FixedVector& v)
{
	os << "(" << v.x << "," << v.y << "," << v.z << ")";
	return os;
}
#endif

FixedVector operator+(const FixedVector& a, const FixedVector& b)
{
	return FixedVector(a.x + b.x, a.y + b.y, a.z + b.z);
}

FixedVector operator/(const FixedVector& a, const Fixed16& b)
{
	return FixedVector(a.x / b, a.y / b, a.z / b);
}

FixedVector operator*(const FixedVector& a, const Fixed16& b)
{
	return FixedVector(a.x * b, a.y * b, a.z * b);
}

FixedVector operator-(const FixedVector& a, const FixedVector& b)
{
	return FixedVector(a.x - b.x, a.y - b.y, a.z - b.z);
}


Fixed16 dot(const FixedVector& a, const FixedVector& b)
{
	return Fixed16::FromFixed32(a.x*b.x + a.y*b.y + a.z*b.z);
}

FixedVector cross(const FixedVector& u, const FixedVector& v)
{
	return FixedVector(u.y*v.z - u.z*v.y, u.z*v.x - u.x*v.z, u.x*v.y - u.y*v.x);
}


/*!\brief Return norm squared of vector
warning the dot product will easily overflow when converted back from Fixed32 to Fixed16 giving spurious results
eg norm2(105,105,105) -> 33075

Scale vector before taking the norm2 if appropriate
*/
Fixed16 norm2(const FixedVector& a)
{
	return dot(a,a);
}

Fixed16 norm(const FixedVector& a)
{
	return sqrt(norm2(a));
}

/*!\brief Return the max element of a vector
	can use as a scaling factor prior to normalising
*/
Fixed16 maxElement(const FixedVector& v)
{
    Fixed16 vx,vy,vz;
    vx = abs(v.x);
    vy = abs(v.y);
    vz = abs(v.z);
    
    if(vx > vy)
    {
        if (vx > vz)
            return vx;
        else
            return vz;
    }
    else
    {
        if(vy > vz)
            return vy;
        else
            return vz;
    }
}

FixedVector normalise(const FixedVector& v)
{
    FixedVector ret = v / maxElement(v);
    ret = ret * invsqrt(norm2(ret));
    return ret; 
}

/*!\brief Return the angle in radians between two vectors
	This is calculated from the formula
	
	a.b = norm(a) norm(b) cos(theta)
	
	Where norm(a) and norm(b) are unity since this is a UnitVector
	
*/
Fixed16 angle(const UnitVector& a, const UnitVector& b)
{
	return arccos(dot(a,b));
}

FixedVector FixedVector::Rotate3D(const Quaternion& q) const
{
	Quaternion me(Fixed16::zero(),x,y,z);

	Quaternion ret = q * me * Quaternion::conjugate(q);
	
	return FixedVector(ret.q1, ret.q2, ret.q3);
}
