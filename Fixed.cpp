/*
Fixed.cpp. A fixed-point arithmetic class for microcontrollers.

Copyright (C) 2005-2006  Tim Molteno tim@physics.otago.ac.nz

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
#include "Fixed.h"

Fixed32::Fixed32( const Fixed16& x )
    : v(x.Raw())
{
    v <<= 16;
}

Fixed32& Fixed32::operator=( const Fixed16& x ) {
    v = x.Raw();
    v <<= 16;
    return *this;
}

Fixed32 operator*(const Fixed32& a, const Fixed32& b ) {
#ifdef IOSTREAMS
    double da = a.toDouble();
    double db = b.toDouble();

    if (abs(da * db) > 0x7fffffff) {
        cout << "OVERFLOW ERROR" << endl;
        cout << "Fixed32::operator*(" << a << "," << b << ")" << endl;
        throw -1;
    }
#endif
//    return Fixed16::FromFixed32(a) * Fixed16::FromFixed32(b);
    return Fixed32::FromRaw((a.Raw() >> 16) * (b.Raw() >> 16));
}


Fixed32 reciprocal(const Fixed32& x)
{
    /*
        We lose a little precision here with the division
        because we would saturate if we actually did the correct
        division of 1 by x. Instead we divide 1/8 by x and multiply
        the answer by 8.
    */
    f_int64 den = (x.Raw() >> 16);
    f_int64 ret = ((f_int64(1) << 48) / den + 1);
/*#ifdef IOSTREAMS
    cout << "den = " << den << endl;
    cout << "ret = " << ((f_int64(1) << 48)) << " / " << den << endl;
    cout << "reciprocal(" << x << ") = " << Fixed32::FromRaw(ret) << endl;
#endif*/
    return Fixed32::FromRaw(ret);
}


#ifdef IOSTREAMS
std::ostream& operator<<(std::ostream& os, const Fixed32& v)
{
    double p = 65536.0*65536.0;
    f_int64 vi = v.Raw();
    double f = double(int32_t(vi.GetHi())) + double(vi.GetLo()) / p;
    
    os << "Fixed32::" << f;
    return os;
}
std::ostream& operator<<(std::ostream& os, const Fixed16& v)
{
    int32_t x = v.Raw();
    double f = (x >> 16) + ( ((double) (x & 0xFFFF)) / 65536.0);
    
    os << f;
    return os;
}

void Fixed32::testharness()
{
    cout << "Fixed32 testharness" << endl;
    Fixed32 x(f_int32(2));
    Fixed32 y(f_int32(4));

    test_result("x+y",(x+y), Fixed32(f_int32(6)));
    test_result("x-y",(x-y), Fixed32(f_int32(-2)));
    test_result("y-x",(y-x), Fixed32(f_int32(2)));
    test_result("x*y",(x*y), Fixed32(f_int32(8)));
    test_result("x/8",(x/8), Fixed32(0.25));

    cout << "2*4 = " << (x*y) << endl;
    cout << "2-4 = " << (x-y) << endl;
    cout << "2/4 = " << (x/y) << endl;
    cout << "(2*4)/4 = " << ((x*y)/y) << endl;
    cout << "(2+4)/4 = " << ((x+y)/y) << endl;

    Fixed32 x1 = Fixed32::FromRaw(f_int64(800000,1823000000));
    Fixed32 y1 = Fixed32::FromRaw(f_int64(64567,456000000));
    cout << "x = " << (x1) << endl;
    cout << "x+y = " << (x1+y1) << endl;
    
    // this should fail! as we are out of range...
    //cout << "x*y = " << (x1*y1) << endl;

    Fixed32 a(0.46);
    Fixed32 b(-0.19);
    cout << "a = " << (a) << endl;
    cout << "b = " << (b) << endl;

    test_result("a + b",(a + b), Fixed32(0.27), Fixed32(0.0001));
    test_result("a - b",(a - b), Fixed32(0.65), Fixed32(0.0001));
    test_result("a * b",(a * b), Fixed32(-0.0874), Fixed32(0.0001));
    test_result("a / b",(a / b), Fixed32(-2.42105), Fixed32(0.0001));
}


void Fixed16::testharness()
{
    cout << "Fixed16 testharness" << endl;

    Fixed16 tol(Fixed32(0.001));    // accuracy

    Fixed16 a(6);
    Fixed16 b(3);
    test_result("-a",(-a), Fixed16(-6));
    test_result("a + b",(a + b), Fixed16(9));
    test_result("a - b",(a - b), Fixed16(3));
    test_result("a * b",Fixed16(a * b), Fixed16(18));
    test_result("a / b",(a / b), Fixed16(2), tol);

    Fixed16 zero(0);

    test_result("arctan2(0,1)",arctan2(zero,one()), Fixed16::zero());
    test_result("arctan2(0,-1)",arctan2(zero,-one()), Fixed16::PI(), tol);
    test_result("arctan2(1,1)",arctan2(one(),one()), Fixed16::PI()/4, tol);
    test_result("arctan2(1,0)",arctan2(one(),zero), Fixed16::PI()/2, tol);
    test_result("arctan2(1,-1)",arctan2(one(),-one()), Fixed16::PI() - Fixed16::PI()/4, tol << 4);
    test_result("arctan2(-1,1)",arctan2(-one(),one()), -Fixed16::PI()/4, tol << 4);
    test_result("arctan2(-1,0)",arctan2(-one(),zero), -Fixed16::PI()/2, tol);
    test_result("arctan2(-1,-1)",arctan2(-one(),-one()), -Fixed16::PI()  + Fixed16::PI()/4, tol);

    Fixed16 pi4 = Fixed16::PI()/4;

    test_result("arcsin(sin(pi/4))", arcsin(sin(pi4)), pi4, tol);
    test_result("arcsin(sin(-pi/4))", arcsin(sin(-pi4)), -pi4, tol);
    test_result("arccos(cos(pi/4))", arccos(cos(pi4)), pi4, tol);
    test_result("arccos(cos(-pi/4))", arccos(cos(-pi4)), pi4, tol);

    Fixed16 pi32 = (Fixed16::PI()/2)*3;

    test_result("arccos(cos(3 pi/2))", arccos(cos(pi32)), pi32 - Fixed16::PI(), tol); //answers in range 0 - PI/2
    test_result("arccos(cos(-3 pi/2))", arccos(cos(-pi32)), pi32 - Fixed16::PI(), tol);//answers in range 0 - PI/2

    test_result("sqrt(4)", sqrt(Fixed16(4)), Fixed16(2), tol);
    test_result("sqrt(9)", sqrt(Fixed16(9)), Fixed16(3), tol);
    test_result("sqrt(64)", sqrt(Fixed16(64)), Fixed16(8), tol);

    test_result("invsqrt(4)", invsqrt(Fixed16(4)), one()/2, tol);
    test_result("invsqrt(9)", invsqrt(Fixed16(9)), one()/3, tol);
    test_result("invsqrt(64)", invsqrt(Fixed16(64)), one()/8, tol);
    
    Fixed16 tol2(Fixed32(0.01));    // accuracy
    for (int i=1;i<1000;i++)
    {
        cout << "invsqrt(" << i << ")";
        test_result(" ", invsqrt(Fixed16(i)), one()/sqrt(Fixed16(i)), Fixed16(tol2*invsqrt(Fixed16(i))));
        Fixed16 ii = Fixed16::one()/Fixed16(i);
        cout << "invsqrt(" << ii << ")";
        test_result(" ", invsqrt(ii), sqrt(Fixed16(i)), Fixed16(tol2*invsqrt(ii)));
    }
}

uint32_t seed = 123456789;

Fixed16 Fixed16::rand(int32_t x)
{
    static const uint32_t a = 1103515245;
    static const uint32_t c = 12345;
    seed = (a * seed + c);
    return Fixed16::FromRaw(seed);
}


#endif /* IOSTREAMS */


Fixed16 Fixed16::zero()
{
    return FromRaw(0);
}
Fixed16 Fixed16::one()
{
    return FromRaw(65536);
}
Fixed16 Fixed16::PI()
{
    return FromRaw(205887);
}
Fixed16 Fixed16::PI_OVER_2()
{
    return FromRaw(102944);
}
Fixed16 Fixed16::PI_3OVER_2()
{
    return FromRaw(308831);
}


/**********************************************************************/
uint32_t divmodsi4(bool modwanted, uint32_t num, uint32_t den);
int32_t __modsi3 (int32_t numerator, int32_t denominator);
int32_t __divsi3 (int32_t numerator, int32_t denominator);

/*!\brief  Division algorithms.
These are included because
the microcontroller (ARM 7) we are targeting does not have
a division instruction
*/
inline void divnorm(int32_t& num, int32_t& den, int32_t& sign)
{
    if (num < 0)
    {
        num = -num;
        sign = 1;
    }
    else
    {
        sign = 0;
    }
    
    if (den < 0)
    {
        den = - den;
        sign = 1 - sign;
    }
}

uint32_t divmodsi4(bool modwanted, uint32_t num, uint32_t den)
{
    int32_t bit = 1;
    int32_t res = 0;
    while (den < num && bit && !(den & (1L<<31)))
    {
        den <<=1;
        bit <<=1;
    }
    while (bit)
    {
        if (num >= den)
        {
            num -= den;
            res |= bit;
        }
        bit >>=1;
        den >>=1; 
    }
    if (modwanted) return num;
    return res;
}

int32_t __modsi3 (int32_t numerator, int32_t denominator)
{
    int sign = 0;
    
    if (numerator < 0) 
    {
        numerator = -numerator;
        sign = 1;
    }
    if (denominator < 0)
    {
        denominator = -denominator;
    }  
    
    int32_t modul =  divmodsi4 (true, numerator, denominator);
    if (0 != sign)
        return -modul;
    return modul;
}

int32_t __divsi3 (int32_t numerator, int32_t denominator)
{
    int sign;
    divnorm (numerator, denominator, sign);
    
    int32_t dividend = divmodsi4 (false,  numerator, denominator);
    if (0 != sign)
        return -dividend;
    return dividend;
}

inline int32_t __umodsi3 (uint32_t numerator, uint32_t denominator)
{
    return divmodsi4 (true,  numerator, denominator);
}

inline int32_t __udivsi3 (uint32_t numerator, uint32_t denominator)
{
    return divmodsi4 (false, numerator, denominator);
}

/**********************************************************************/

Fixed16 reciprocal(const Fixed16& x)
{
    /*
        We lose a little precision here with the division
        because we would saturate if we actually did the correct
        division of 1 by x. Instead we divide 1/8 by x and multiply
        the answer by 8.
    */
#if 0
    f_int32 ret = (__divsi3(1 << 30, x.Raw()) + 1)  >> 1;
    return Fixed16::FromRaw(ret <<  3);
    
#else
    /*
        Use Newtons Method to calculate the reciprocal
        
        f(x) = y = 1/x
        g(y) = y2 = x, the inverse function of f(x)
        g'(y) = 1, the derivative of the inverse function
        
        
        Set up the iteration:
        
        yn+1 = yn - (g(yn) - x)/g'(yn)
        
        y = 2*y - x*y*y
        
        
        y2 = y1 * (two - x*y1);
    */
    Fixed16 two(2);
    
    f_int32 guess = 1;
    f_int32 max = 1 << 30;
    f_int32 raw = abs(x).Raw();
    
    while ((max > 0) && ((max & raw) == 0))
    {
        max = max >> 1;
        guess = guess << 1;
    }
    
    Fixed16 y1;
    if (x > Fixed16::zero())
        y1 = Fixed16::FromRaw(guess);
    else
        y1 = -Fixed16::FromRaw(guess);
    
    // Do six iterations (nice balance between speed and accuracy)
    for (int i=6;i>0;i--)
    {
        y1 = y1 * (two - x*y1);
    }
    
    return y1;
    
#endif
}
    

/*!\brief Calculate square-root of a 16:16 fixed point number by Newton's method
    
    Find 1/sqrt(x) from
    
    y_{n+1} = 0.5*y_n*[3 - x*y_n^2]

    Approximating the square root.

    Take the integer part of the number r. Z = int(r)
    Count the number of digits in Z. Let D be the number of digits.
    The rough estimate is E = 3D.


    TODO Here is a future improvement from http://www.finesse.demon.co.uk/steven/sqrt.html

    Wilco Dijkstra also provided the following C code which produces optimised ARM code which takes 4 cycles per bit: 
    typedef unsigned uint32;
    
    #define iter1(N) \
        try = root + (1 << (N)); \
        if (n >= try << (N))   \
        {   n -= try << (N);   \
                root |= 2 << (N); \
        }
        
    uint32 sqrt (uint32 n)
    {
        uint32 root = 0, try;
        iter1 (15);    iter1 (14);    iter1 (13);    iter1 (12);
        iter1 (11);    iter1 (10);    iter1 ( 9);    iter1 ( 8);
        iter1 ( 7);    iter1 ( 6);    iter1 ( 5);    iter1 ( 4);
        iter1 ( 3);    iter1 ( 2);    iter1 ( 1);    iter1 ( 0);
        return root >> 1;
    }
 */
Fixed16 sqrt(const Fixed16& x)
{
    if (x == Fixed16::zero())
        return Fixed16::zero();
#ifdef DEBUGGING
    if (x < Fixed16::zero())
    {
        cout << "Error. sqrt called on negative number: " << x << endl;
        throw -1;
    }
#endif
    return x*invsqrt(x);
#if 0
    Fixed16 y = x;
    Fixed16 quarter = Fixed16::one() >> 2;
    Fixed16 four(4);
    int n = 0;
    if (y < quarter)
    {
        while (y < quarter)
        {
            y = y << 2;    // multiply by 4
            n += 1;
        }
        y = x << n;
    }
    else if (y > four)
    {
        while (y > four)
        {
            y = y >> 2;    // divide by 4
            n += 1;
        }
        y = x >> n;
    }
    
    // Do 6 iterations
    for (int i = 0; i < 6; i++)
    {
        y = (y + (x/y)) / 2;
    }
    return y;
#endif
}



/*!\brief Calculate the inverse square root
*/
Fixed16    invsqrt(const Fixed16& x)
{
    if (x <= Fixed16::zero())
    {
#ifdef DEBUGGING
        cout << "Error. invsqrt called on negative number: " << x << endl;
        throw -1;
#endif
        return Fixed16::zero();
    }
    Fixed16 y = x;        // starting approximation
    int n = 0;
    if (y < Fixed16::one())
    {
        while (y < Fixed16::one())
        {
            y = y << 2;    // multiply by 4
            n += 1;
        }
        y = Fixed16::one() << (n-1);
    }
    else if (y > Fixed16::one())
    {
        while (y > Fixed16::one())
        {
            y = y >> 2;    // divide by 4
            n += 1;
        }
        y = Fixed16::one() >> n;
    }
//    cout << "Approximation invsqrt(" << x << ") = " << y << endl;
    
    Fixed32 three = Fixed32(int32_t(3));
    Fixed16 half = Fixed16::one() >> 1;
    for (int i = 5; i > 0; i--)
    {
        y = half*y*(three - x*y*y);
//        cout << "y=" << y << endl;
    }
    return y;
//    return reciprocal(sqrt(x));
}


/*!\brief Calculate square-root of a Fixed32 (32.32) fixed point number. 
    (approximate) by normalizing the number to 16:16 and
    then renormalizing the sqrt.
    
    We do this because we would like to be able to normalize vectors
    with co-efficients larger than 256. So if the number is small enough
    we just take the sqrt(). However if the number is too big we divide
    it down by powers of 4. For each division by 4, we multiply the
    result by two since
        sqrt(x / 4^n)     == sqrt(x)/2^n
    so    sqrt(x)        == 2^n * sqrt(x / 4^n)


*/
Fixed16 sqrt(const Fixed32& x)
{
    if (x.is_Fixed16_compatable())
        return sqrt(Fixed16::FromFixed32(x));
        
    Fixed32 t(x);
    int n = 0;
    while (false == t.is_Fixed16_compatable())
    {
        t.shiftr(2);    // divide by 4
        n += 1;
    }
    
    Fixed16 ret = Fixed16::FromFixed32(t);        // now coerce to Fixed16
    ret = sqrt(ret);    // and take the sqrt()
    ret = (ret << n);    // multiply by 2^n
    return ret;
}


/*!\brief Calculate sin(x) where x is in radians (0 <= x <= 2PI)
*/    
Fixed16 sin(const Fixed16& x)
{
#ifdef IOSTREAMS
    double xd = x.toDouble();
    if ((xd > 6.28) || (xd < -6.28))
    {
        cerr << "Fixed16::sin(" << xd << ") out of range" << endl;
        throw -1;
    }
#endif
    if (x < Fixed16::zero())
        return -sin(-x);

    Fixed16 f(x);
    int sign = 1;
    if ((x > Fixed16::PI_OVER_2()) && (x <= Fixed16::PI()))
    {
        f = Fixed16::PI() - x;
    } else if ((x > Fixed16::PI_OVER_2()) && (x <= (Fixed16::PI_3OVER_2())))
    {
        f = x - Fixed16::PI();
        sign = -1;
    } else if (x > (Fixed16::PI_3OVER_2()))
    {
        f = Fixed16::FromFixed32(Fixed16::PI()*Fixed16(2))-x;
        sign = -1;
    }
    
    Fixed16 sqr = Fixed16::FromFixed32(f*f);
    Fixed16 result = Fixed16::FromRaw(498);
    result *= sqr;
    result -= Fixed16::FromRaw(10882);
    result *= sqr;
    result += Fixed16::one();
    result *= f;
    return Fixed16::FromFixed32(result*sign);
}
    
    #define CK1 2428
    #define CK2 32551
    
/*!\brief Calculate cos(f), f in radians.
    calculates for -inf <= f <= inf, using 0 <= f <= PI/2
*/
Fixed16 cos(const Fixed16& f)
{
    if (f < Fixed16::zero())            //covers negatives
        return cos(-f);

    if (f > Fixed16::PI_OVER_2())            //extends range
        return -cos(f - Fixed16::PI());

    Fixed16 sqr = Fixed16::FromFixed32(f*f);
    Fixed16 result = Fixed16::FromRaw(CK1);
    result  *= sqr;
    result -= Fixed16::FromRaw(CK2);
    result  *= sqr;
    result += Fixed16::one();
    return result;
}
    
    
/*!\brief Calculate tan(f), f is in radians (0 <= f <= PI/4)
*/    
    #define TK1 13323
    #define TK2 20810
    
Fixed16 tan(const Fixed16& f)
{
#ifdef IOSTREAMS
    double xd = f.toDouble();
    if ((xd > 3.15/4) || (xd < 0))
    {
        cerr << "Fixed16::tan(" << xd << ") out of range" << endl;
        throw -1;
    }
#endif
    Fixed16 sqr = Fixed16::FromFixed32(f*f);
    Fixed16 result = Fixed16::FromRaw(TK1);
    result *= sqr;
    result += Fixed16::FromRaw(TK2);
    result *= sqr;
    result += Fixed16::one();
    result *= f;
    return result;
}
    
#define AS1 -1228
#define AS2 4866
#define AS3 13901
#define AS4 102939

/*!\brief Calculate arcsin(f), -1 <= f <= 1
\returns a number between -PI/2 and PI/2
*/
Fixed16 arcsin(const Fixed16& f)
{
#ifdef IOSTREAMS
    double xd = f.toDouble();
    if ((xd > 1) || (xd < -1))
    {
        cerr << "Fixed16::arcsin(" << xd << ") out of range" << endl;
        throw -1;
    }
#endif
    if (f < Fixed16::zero())
        return -arcsin(-f);
        
    // Approximation below only works for 0 <= f <= 1
    Fixed16 fRoot = sqrt(Fixed16::one()-f);
    Fixed16 result = Fixed16::FromRaw(AS1);
    result *= f;
    result += Fixed16::FromRaw(AS2);
    result *= f;
    result -= Fixed16::FromRaw(AS3);
    result *= f;
    result += Fixed16::FromRaw(AS4);
    return Fixed16::PI_OVER_2() - Fixed16::FromFixed32(fRoot*result);
}


/*!\brief Calculate arccos(f), -1 <= f <= 1

    Returns numbers between zero and PI
    
    TODO Test this because it appears a little broken for negative input
*/
Fixed16 arccos(const Fixed16& f)
{
#ifdef IOSTREAMS
    double xd = f.toDouble();
    if ((xd > 1) || (xd < -1))
    {
        cerr << "Fixed16::arccos(" << xd << ") out of range" << endl;
        std::exit(1);
    }
#endif
    if (f < Fixed16::zero())
        return Fixed16::PI() - arccos(-f);
        
    // Approximation below only works for 0 <= f <= 1
    Fixed16 fRoot = sqrt(Fixed16::one()-f);
    Fixed16 result = Fixed16::FromRaw(AS1);
    result *= f;
    result += Fixed16::FromRaw(AS2);
    result *= f;
    result -= Fixed16::FromRaw(AS3);
    result *= f;
    result += Fixed16::FromRaw(AS4);
    return Fixed16::FromFixed32(fRoot * result);
}

#define ATK1 18350
/*!\brief Calculate arctan(f)
\returns results in the range -pi/2 <= f <= pi/2

We use the polynomial approximation:
x/(1 + 0.28 * x^2)

A Better approximation is given by...
arctan(x) = (x + 0.43157974*x^3)/(1 + 0.76443945*x^2 + 0.05831938*x^4)

Expressing as partial fractions (Using Mathematica):

=(0.6141573891344294*x)/(1.4738740432728408 + Power(x,2)) + 
   (6.786122586407148*x)/(11.63393763099393 + Power(x,2))

=(Fixed16::FromRaw(40249)*x)/(Fixed16::FromRaw(96592) + sqr) + 
   (Fixed16::FromRaw(444737)*x)/(Fixed16::FromRaw(762440) + sqr)
*/    
Fixed16 arctan(const Fixed16& x)
{
    if (x > Fixed16::one())
    {
        return Fixed16::PI_OVER_2() - arctan(reciprocal(x));
    }
    else if (x < -Fixed16::one())
    {
        return -Fixed16::PI_OVER_2() - arctan(reciprocal(x));
    }
    
    // Now we are sure that |f| <= 1, so continue with the approximation
    Fixed32 sqr = (x*x);
//    return f / (Fixed16::FromFixed32(sqr * Fixed16::FromRaw(ATK1)) + Fixed16::one());
    return (Fixed16::FromRaw(40249)*x)/(Fixed16::FromRaw(96592) + sqr) + 
   (Fixed16::FromRaw(444737)*x)/(Fixed16::FromRaw(762440) + sqr);
}

/*!\brief Calculate arctan(y/x), coping with zero for x. 
* Performs the trigonometric arctangent operation on y/x and
* returns an angle in the range from -PI to PI expressed in radians,
* using the signs of the parameters to determine the quadrant.
* The result is valid even if x is 0 (angle is PI/2 or -PI/2).
\returns in radians and has a value equal to the principal value of the argument of the complex number (X, Y). It is in the range -PI \< ATAN2(Y, X) <= PI.
If X <> 0, the result approximates arctan(Y/X).
If Y > 0, the result is positive.
If Y < 0, the result is negative.
If Y = 0 and X > 0, the result is zero.
If Y = 0 and X < 0, the result is PI.
If X = 0, the absolute value of the result is PI/2.
*/    
Fixed16 arctan2(const Fixed16& y , const Fixed16& x)
{
    if ((x == 0) && (y == 0))
    {
#ifdef IOSTREAMS
        cerr << "Fixed16::arctan(0,0)" << endl;
        throw -1;
#endif
        return Fixed16::zero(); // same as GCC's atan2
    }
    
    if (y < Fixed16::zero())
        return -arctan2(-y,x);

    if (x == Fixed16::zero())
    {
        return Fixed16::PI_OVER_2();
    }

    if (y == Fixed16::zero())
    {
        if (x > Fixed16::zero())
            return Fixed16::zero();
        if (x < Fixed16::zero())
            return Fixed16::PI();
    }

    if (x > Fixed16::zero())
        return arctan(y/x);
    if (x < Fixed16::zero())
        return arctan(y/x) + Fixed16::PI();

    return Fixed16::zero();
}


/*!\brief Round to the nearest integer.
*/
Fixed16 round(const Fixed16& f)
{
    f_int32 n = abs(f).Raw();
    
    f_int32 ret;
        
    if ((n & 0x8000) != 0)
    {
        ret = (((n+0x10000)>>16)<<16);
    }
    else
    {
        ret = (((n)>>16)<<16);
    }
    if (f.Raw() < 0)
        ret = -ret;
        
    return Fixed16::FromRaw(ret);
}

/*!\brief Convert degrees to radians.
    We multiply by the constant Pi / 180
    and convert this to fixed with
    Pi / 180 = Fixed16::FromRaw(1144)
*/
Fixed16 deg_to_rad(Fixed16 val)
{
    return Fixed16::FromFixed32(val * Fixed16::FromRaw(1144));
}

/*!\brief Convert degrees to radians.
    We use the constant 180 / Pi = 57.xxx
    and convert this to fixed with
    180 / Pi = Fixed16::FromRaw(3754936)
*/
Fixed16 rad_to_deg(Fixed16 val)
{
    return Fixed16::FromFixed32(val * Fixed16::FromRaw(3754936));
}

