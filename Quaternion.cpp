/*
Quaternion.cpp. Fixed point quaternions for microcontrollers.

Copyright (C) 2005-2006  Matthew Chave mattchave@hotmail.com

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/


#include "Quaternion.h"




///test2 in matlab
bool Quaternion::test_inRange(Fixed16 a, Fixed16 b, Fixed16 error)
{
	if (((a - error) <= b) & ((a + error) >= b))
	{
		return  true;
	}else
	{
		return  false;
	}
}


///from matlab
Quaternion Quaternion::conjugate(const Quaternion& q)
{
	return Quaternion(q.q0, -q.q1, -q.q2, -q.q3);
}



///from matlab
/**
	q1 can be non-normalised quaternion

	Note on Euler Angles.

	We use the NASA standard aeroplane co-ordinates 

	X positive along length of aircraft toward nose,
	Y positive along starboard wing and
	Z positive down.
	
	Heading (psi) = rotation about z axis
	Attitude (phi) = rotation about y axis
	Bank (theta) = rotation about x axis

	Heading applied first
	Attitude applied second
	Bank applied last
*/
void Quaternion::get_euler(Fixed16& theta, Fixed16&phi, Fixed16& psi) const
{
	Fixed16 errorE = Fixed16(1)/1000; 				//TODO find the optimal and minimum one of these for a fixed16
	
	if (Quaternion::test_inRange(q0, q2, errorE) & Quaternion::test_inRange(q1, -q3, errorE))
	{ 
		//singularity at north pole
		psi = -Fixed16(2) * arctan2(q1,q0);
		phi = Fixed16::PI()/2;
		theta = Fixed16(0);
		return;
	}
	else if (test_inRange(q0, -q2, errorE) & test_inRange(q1, q3, errorE)) 
	{
		//singularity at south pole
		psi = Fixed16(2) * arctan2(q1,q0);
		phi = -Fixed16::PI()/2;
		theta = Fixed16(0);
		return;
	}
	else
	{  
		theta = arctan2(Fixed16(Fixed16(2)*(q0*q1+q2*q3)) , (Fixed16(1) - Fixed16(Fixed16(2)*(Fixed16(q1*q1) + Fixed16(q2*q2)))));    	//roll
		
		Fixed16 arc_arg = Fixed16(2)*(Fixed16(q0*q2) - Fixed16(q3*q1));
		if (arc_arg > Fixed16(1)) //FIXME wish we didnt have to do this check every time
		{
			arc_arg = 1;
		}
		else if (arc_arg < -Fixed16(1))
		{
			arc_arg = -Fixed16(1);
		}
#ifdef IOSTREAMS
		double arg = 2.0 * (q0.toDouble() * q2.toDouble() - q3.toDouble() * q1.toDouble());
		if ((arg > 1.0) || (arg < -1.0))
		{
			cerr << "test::arcsin(" << arg << ") out of range" << endl;
			cerr << *this << endl;
			//exit(1);
		}
#endif
		phi = arcsin(arc_arg);                              				//pitch
		psi = arctan2(Fixed16(2)*(Fixed16(q0*q3)+Fixed16(q1*q2)) , (Fixed16(1) - Fixed16(2)*(Fixed16(q2*q2) + Fixed16(q3*q3))));      	//yaw
	}
}



///from matlab
// Quaternion q = Quaternion::from_euler(Fixed16(1.23)...
// Construct a Quaternion from the Euler angles in radians NED Nasa standard aerospace
Quaternion Quaternion::from_euler(Fixed16& theta, Fixed16& phi, Fixed16& psi)
{
	Fixed16 c1 = cos(theta/2);
	Fixed16 s1 = sin(theta/2);
	Fixed16 c2 = cos(phi/2);
	Fixed16 s2 = sin(phi/2);
	Fixed16 c3 = cos(psi/2);
	Fixed16 s3 = sin(psi/2);

	Fixed16 c1c2 = c1*c2;
	Fixed16 s1s2 = s1*s2;

	Quaternion ret(0,0,0,0);

	ret.q0 = Fixed16(c1c2*c3)  + Fixed16(s1s2*s3);
	ret.q1 = Fixed16(s1*c2*c3) - Fixed16(c1*s2*s3);
	ret.q2 = Fixed16(c1*s2*c3) + Fixed16(s1*c2*s3);
	ret.q3 = Fixed16(c1c2*s3)  - Fixed16(s1s2*c3);

#ifdef IOSTREAMS
	if((ret.q0.toDouble() > 1.01) |(ret.q1.toDouble() > 1.01) |(ret.q2.toDouble() > 1.01) |(ret.q3.toDouble() > 1.01))
	{
		cout << "Quaternion::from_euler(" << theta << "," << phi << "," << psi << ") = " << ret << endl;
		cout << "s1 = " << s1 << endl;
		cout << "s2 = " << s2 << endl;
		cout << "s3 = " << s3 << endl;
		cout << "c1 = " << c1 << endl;
		cout << "c2 = " << c2 << endl;
		cout << "c3 = " << c3 << endl;
		cout << "s1*c2*c3 = " << s1*c2*c3 << endl;
		cout << "c1*s2*s3 = " << c1*s2*s3 << endl;
		cout << "s1*c2*c3 - c1*s2*s3 = " << (s1*c2*c3 - c1*s2*s3) << endl;
	}
#endif
	return ret;
}


bool operator!=(const Quaternion& a, const Quaternion& b)
{
	if (a.q0 != b.q0) return true;
	if (a.q1 != b.q1) return true;
	if (a.q2 != b.q2) return true;
	if (a.q3 != b.q3) return true;

	return false;	
}

Quaternion operator*(const Quaternion& a, const Quaternion& b)
{
	Quaternion ret(0,0,0,0);
	ret.q0 = -Fixed16(a.q1 * b.q1) - Fixed16(a.q2 * b.q2) - Fixed16(a.q3 * b.q3) + Fixed16(a.q0 * b.q0);
	ret.q1 =  Fixed16(a.q1 * b.q0) + Fixed16(a.q2 * b.q3) - Fixed16(a.q3 * b.q2) + Fixed16(a.q0 * b.q1);
	ret.q2 = -Fixed16(a.q1 * b.q3) + Fixed16(a.q2 * b.q0) + Fixed16(a.q3 * b.q1) + Fixed16(a.q0 * b.q2);
	ret.q3 =  Fixed16(a.q1 * b.q2) - Fixed16(a.q2 * b.q1) + Fixed16(a.q3 * b.q0) + Fixed16(a.q0 * b.q3);

	return ret;
}


Quaternion operator+(const Quaternion& a, const Quaternion& b) 
{
	Quaternion ret(0,0,0,0);
	ret.q0 = a.q0 + b.q0;
	ret.q1 = a.q1 + b.q1;
	ret.q2 = a.q2 + b.q2;
	ret.q3 = a.q3 + b.q3;
	
	return ret;
}

#ifdef IOSTREAMS
std::ostream& operator<<(std::ostream& os, const Quaternion& v)
{
	os << "<" << v.q0 << "," << v.q1 << "," << v.q2 << "," << v.q3 << ">";
	return os;
}


/* static */
bool Quaternion::testharness()
{
	Fixed16 a(1);
	Fixed16 b(0);
	Fixed16 tol = Fixed16::one() / 1000;

	Quaternion q(1,1,0,1);
	
//	test_result("q*q", q*q, Quaternion(-2,0,0,0));
	test_result("norm",q.norm(),sqrt(Fixed16(3)));

	q = Quaternion::normalize(q);
	test_result("normalize",q.norm(),Fixed16(1),tol);

	Fixed16 measured_theta = Fixed16(0);
	Fixed16 measured_phi = Fixed16(0);
	Fixed16 measured_psi = Fixed16(0);
	Fixed16 theta, phi, psi;

	q =  Quaternion::from_euler(measured_theta,measured_phi,measured_psi);
	q.get_euler(theta, phi, psi);
	
	
	cout << "testbenchE>Q>E: "<<endl;
	Quaternion testq(0,0,0,0);
	Fixed16 thetatest, phitest, psitest;
	for(int k = -1; k <= 1; k ++)
	{
		for(int j = -1; j <= 1; j ++)
		{
			for(int i = -1; i <= 1; i ++)
			{
				Fixed16 radnumi = Fixed16::PI()*i;
				Fixed16 radnumj = Fixed16::PI()*j/2;
				Fixed16 radnumk = Fixed16::PI()*k;
				Fixed16 radnumir;
				Fixed16 radnumjr;
				Fixed16 radnumkr;
				Fixed16 error = Fixed16(1)/100;
				
				if ((i != 0)&(j != 0)&(k != 0))
				{
					testq =  Quaternion::from_euler(radnumi,radnumj,radnumk);
					testq.get_euler(radnumir, radnumjr, radnumkr);
					
					test_result("i",radnumi, radnumir, error);
					test_result("j",radnumj, radnumjr, error);
					test_result("k",radnumk, radnumkr, error);
				}
			}
		}
	}

	cout << "Quaternion testharness complete" << endl;
	return false;
}

#endif

