/*
    Class for a 64 bit integer

Copyright (C) 2006  Tim Molteno tim@molteno.net

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/

#ifndef __F_INT64__
#define __F_INT64__

#include <stdint.h>

typedef int32_t f_int32;
typedef uint32_t f_uint32;
typedef int16_t f_int16;

#ifdef IOSTREAMS
    #include <iostream>
    #define DEBUG_ASSERT_MESS(a__,mess__) { if (!(a__)) { std::cout << __FILE__ << ":" << __LINE__ << ": Assert " << mess__ << std::endl; throw -1; } }
#endif
class f_uint64;

/*!\brief    Class for a 64-bit signed integer.

    This is needed to handle the product of two Fixed16 objects.
*/
class f_int64
{
public:
    f_int64()
        :    m_hi(0), m_lo(0)
    { }

    explicit f_int64(const f_int32& l) { *this = l; }

    explicit f_int64(const f_int32& hi, const f_uint32& lo)
        :    m_hi(hi), m_lo(lo)
    { }

    f_int64& operator=(const f_int32& l)
    {
        m_lo = l;
        if (l < 0)
            m_hi = -1L;
        else
            m_hi = 0L;
        return *this;
    }

#ifdef IOSTREAMS
    f_int64& FromDouble(double d);
    double ToDouble() const;
#endif

    f_int32 GetHi() const { return m_hi; }
    f_uint32 GetLo() const { return m_lo; }

    /*!\brief Get the absolute value */
    f_int64 abs() const { return f_int64(*this).abs(); }
    f_int64& abs()
    {
        if ( m_hi < 0 )
            m_hi = -m_hi;
        return *this;
    }

    /*!\brief Convert to a signed 32-bit integer.
    \throw int32_t exception if the conversion will overflow.
    */
    f_int32 toInt32() const
    {
#ifdef IOSTREAMS
        if ( !((m_hi == 0l) || (m_hi == -1l)))
        {
            std::cout << "f_int64 (" << *this << ") f_int32 conversion: loss of precision hi=" << m_hi << std::endl;
            throw -1;
        }
#endif
        return (f_int32)m_lo;
    }


    /*!\brief Multiply two 32-bit integers. */
#ifdef NO_64BIT_MULTIPLY
    static f_int64 mult32(f_int32 u, f_int32 v);
#else
    inline static f_int64 mult32(f_int32 u, f_int32 v)
    {
        int64_t ret = (int64_t) u * (int64_t) v;
        return f_int64(long(ret >> 32 & 0xFFFFFFFF), ret & 0xFFFFFFFF);
    }
#endif


    f_int64 operator+(const f_int64& ll) const;
    f_int64& operator+=(const f_int64& ll);
    f_int64 operator+(f_int32 l) const;
    f_int64& operator+=(f_int32 l);

    f_int64& operator++();
    f_int64& operator++(int32_t) { return ++(*this); }

        // negation operator
    f_int64 operator-() const;
    f_int64& Negate();

    f_int64 operator-(const f_int64& ll) const;
    f_int64& operator-=(const f_int64& ll);

        // pre decrement operator
    f_int64& operator--();

        // post decrement operator
    f_int64& operator--(int32_t) { return --(*this); }

    /*!\brief Shift left */
    f_int64 operator<<(int32_t shift) const;
    f_int64& operator<<=(int32_t shift);

    /*!\brief Shift right */
    f_int64 operator>>(int32_t shift) const;
    f_int64& operator>>=(int32_t shift);

    /*!\brief Bitwise AND. */
    f_int64 operator&(const f_int64& ll) const;
    f_int64& operator&=(const f_int64& ll);

    /*!\brief Bitwise OR. */
    f_int64 operator|(const f_int64& ll) const;
    f_int64& operator|=(const f_int64& ll);

    /*!\brief Bitwise XOR. */
    f_int64 operator^(const f_int64& ll) const;
    f_int64& operator^=(const f_int64& ll);

    /*!\brief Bitwise NOT. */
    f_int64 operator~() const;

    inline bool operator==(const f_int64& ll) const
        { return m_lo == ll.m_lo && m_hi == ll.m_hi; }

    inline bool operator!=(const f_int64& ll) const
        { return !(*this == ll); }

    bool operator<(const f_int64& ll) const;
    bool operator>(const f_int64& ll) const;

    inline bool operator<=(const f_int64& ll) const
        { return *this < ll || *this == ll; }
    inline bool operator>=(const f_int64& ll) const
        { return *this > ll || *this == ll; }

    bool operator<(f_int32 l) const { return *this < f_int64(l); }
    bool operator>(f_int32 l) const { return *this > f_int64(l); }
    bool operator==(f_int32 l) const
    {
        if (l >= 0)
            return (m_hi == 0 && m_lo == (f_uint32)l);
        else
            return (m_hi == -1 && m_lo == (f_uint32)l);
    }

    bool operator<=(f_int32 l) const { return *this < l || *this == l; }
    bool operator>=(f_int32 l) const { return *this > l || *this == l; }

    // multiplication
    f_int64 operator*(const f_int64& ll) const;
    f_int64& operator*=(const f_int64& ll);

    // division
    f_int64 operator/(const f_int64& ll) const;
    f_int64& operator/=(const f_int64& ll);

    f_int64 operator%(const f_int64& ll) const;

    void Divide(const f_int64& divisor,
                f_int64& quotient,
                f_int64& remainder) const;

#ifdef IOSTREAMS
    static void testharness();
    friend std::ostream& operator<<(std::ostream&, const f_int64&);
#endif

private:
    f_int32 m_hi;
    f_uint32 m_lo;

};


/*!\brief    Class for a 64-bit unsigned integer.
*/
class f_uint64
{
public:
    f_uint64()
        :    m_hi(0), m_lo(0)
    { }

    explicit f_uint64(const f_uint32& l) { *this = l; }

    explicit f_uint64(const f_uint32& hi, const f_uint32& lo)
        :    m_hi(hi), m_lo(lo)
    { }

    explicit f_uint64(const f_int64& ll)
        :    m_hi((f_uint32)ll.GetHi()), m_lo(ll.GetLo())
    {
#ifdef IOSTREAMS
        if (ll.GetHi() < 0)
        {
            std::cout << "f_uint64 constructed from negative number " << ll.GetHi() << std::endl;
            throw -1;
        }
#endif
    }

    f_uint64& operator=(const f_uint32& l)
    {
        m_lo = l;
        m_hi = 0;
        return *this;
    }

    f_uint32 GetHi() const { return m_hi; }
    f_uint32 GetLo() const { return m_lo; }

        // convert to f_int32 with range checking in the debug mode (only!)
    f_uint32 ToULong() const
    {
#ifdef IOSTREAMS
        DEBUG_ASSERT_MESS( m_hi == 0ul,
                    "f_uint64 to f_int32 conversion loss of precision" );
#endif

        return (f_uint32)m_lo;
    }

    f_uint64 operator+(const f_uint64& ll) const;
    f_uint64& operator+=(const f_uint64& ll);
    f_uint64 operator+(f_uint32 l) const;
    f_uint64& operator+=(f_uint32 l);

        // pre increment operator
    f_uint64& operator++();

        // post increment operator
    f_uint64& operator++(int32_t) { return ++(*this); }

        // subtraction
    f_int64 operator-(const f_uint64& ll) const;
    f_uint64& operator-=(const f_uint64& ll);

        // pre decrement operator
    f_uint64& operator--();

        // post decrement operator
    f_uint64& operator--(int32_t) { return --(*this); }

    // shifts
        // left shift
    f_uint64 operator<<(int32_t shift) const;
    f_uint64& operator<<=(int32_t shift);

        // right shift
    f_uint64 operator>>(int32_t shift) const;
    f_uint64& operator>>=(int32_t shift);

    // bitwise operators
    f_uint64 operator&(const f_uint64& ll) const;
    f_uint64& operator&=(const f_uint64& ll);
    f_uint64 operator|(const f_uint64& ll) const;
    f_uint64& operator|=(const f_uint64& ll);
    f_uint64 operator^(const f_uint64& ll) const;
    f_uint64& operator^=(const f_uint64& ll);
    f_uint64 operator~() const;

    // comparison
    bool operator==(const f_uint64& ll) const
        { return m_lo == ll.m_lo && m_hi == ll.m_hi; }
    bool operator!=(const f_uint64& ll) const
        { return !(*this == ll); }
    bool operator<(const f_uint64& ll) const;
    bool operator>(const f_uint64& ll) const;
    bool operator<=(const f_uint64& ll) const
        { return *this < ll || *this == ll; }
    bool operator>=(const f_uint64& ll) const
        { return *this > ll || *this == ll; }

    bool operator<(f_uint32 l) const { return *this < f_uint64(l); }
    bool operator>(f_uint32 l) const { return *this > f_uint64(l); }
    bool operator==(f_uint32 l) const
    {
        return (m_hi == 0 && m_lo == (f_uint32)l);
    }

    bool operator<=(f_uint32 l) const { return *this < l || *this == l; }
    bool operator>=(f_uint32 l) const { return *this > l || *this == l; }

    // multiplication
    f_uint64 operator*(const f_uint64& ll) const;
    f_uint64& operator*=(const f_uint64& ll);

    // division
    f_uint64 operator/(const f_uint64& ll) const;
    f_uint64& operator/=(const f_uint64& ll);

    f_uint64 operator%(const f_uint64& ll) const;

    void Divide(const f_uint64& divisor,
                f_uint64& quotient,
                f_uint64& remainder) const;

    f_int64 toLongLong() const
    {
        return f_int64((f_int32)GetHi(),GetLo());
    }

#ifdef IOSTREAMS
    friend std::ostream& operator<<(std::ostream&, const f_uint64&);
#endif // IOSTREAMS

private:

    f_uint32 m_hi;
    f_uint32 m_lo;
};


// ----------------------------------------------------------------------------
// binary operators
// ----------------------------------------------------------------------------

inline bool operator<(f_int32 l, const f_int64& ll) { return ll > l; }
inline bool operator>(f_int32 l, const f_int64& ll) { return ll < l; }
inline bool operator<=(f_int32 l, const f_int64& ll) { return ll >= l; }
inline bool operator>=(f_int32 l, const f_int64& ll) { return ll <= l; }
inline bool operator==(f_int32 l, const f_int64& ll) { return ll == l; }
inline bool operator!=(f_int32 l, const f_int64& ll) { return ll != f_int64(l); }

inline f_int64 operator+(f_int32 l, const f_int64& ll) { return ll + l; }
inline f_int64 operator-(f_int32 l, const f_int64& ll)
{
    return f_int64(l) - ll;
}

inline bool operator<(f_uint32 l, const f_uint64& ull) { return ull > l; }
inline bool operator>(f_uint32 l, const f_uint64& ull) { return ull < l; }
inline bool operator<=(f_uint32 l, const f_uint64& ull) { return ull >= l; }
inline bool operator>=(f_uint32 l, const f_uint64& ull) { return ull <= l; }
inline bool operator==(f_uint32 l, const f_uint64& ull) { return ull == l; }
inline bool operator!=(f_uint32 l, const f_uint64& ull) { return ull != f_uint64(l); }

inline f_uint64 operator+(f_uint32 l, const f_uint64& ull) { return ull + l; }

inline f_int64 operator-(f_uint32 l, const f_uint64& ull)
{
    f_int64 ret = f_uint64(l) - ull;
    return ret;
}

#endif // __F_INT64__
