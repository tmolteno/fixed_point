#ifndef __Fixed_h__
#define __Fixed_h__
/*
Fixed.h. Fixed point arithmetic class for microcontrollers.

Copyright (C) 2005-2006  Tim Molteno tim@molteno.net

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.


How to use the Fixed16 class

Fixed16 x(12); // create a fixed16 equal to 12.
Fixed16 y(14);

Fixed16 z = x*y;
Fixed16 t = Fixed16::one() / 2; // half
Fixed16 x2 = sqrt(t);
*/

#ifdef IOSTREAMS
    #include <iostream>
    #include <cmath>
    #include <cstdlib>
    using namespace std;



template <class Type> void test_result(const char* message, const Type& x, const Type& y, const Type& err = Type())
{
    if ((err == Type()) && (x != y))
    {
        cout << "FAILED " << message << ": " << x << " != " << y << endl;
        throw -1;
    }
    if ((err != Type()) && (err < abs(x - y)))
    {
        cout << "FAILED " << message << ": " << x << " != " << y << "+/-" << err << endl;
        throw -1;
    }

    cout << "Passed " << message << " = " << y << "\t(" << x << ")" << endl;
}


#endif




class Fixed32;
class Fixed16;

#include "f_int64.h"

/*!\brief Fixed32: A 64 bit (32.32) fixed-point number

* This class is used to hold the product of multiplying two Fixed16 numbers
* and in order to support the idea of normalizing a vector (calculating its
* norm) we support addition and square root operations on Fixed32 numbers.

*/
class Fixed32
{
public:

    explicit Fixed32() {}
    explicit Fixed32( const f_int32& i ) {
        f_int64 temp(i);
        temp <<= 32;
        v = temp;
    }
    explicit Fixed32( const Fixed16& x );
    
    Fixed32& operator=( const Fixed16& rhs );
    
    static Fixed32 FromRaw( const f_int64& raw ) {
        Fixed32 r;
        r.v = raw;
        return r;
    }
    
#ifdef IOSTREAMS
    double toDouble() const {
        double f = double(v.GetHi()) + double(v.GetLo()) / (65536.0*65536.0);
        return f;
    }
    
    explicit Fixed32(const double x) {
        v.FromDouble(x*65536.0*65536.0);
    }

    static Fixed32 FromDouble(const double x) {
        Fixed32 ret;
        ret.v.FromDouble(x*65536.0*65536.0);
        return ret;
    }
    
#endif
    
    inline bool is_Fixed16_compatable() const {
        if (v.GetHi() < 0x7FFF) {
            return true;    // a positive number after shifting 16 bits
        }
        return false;
    }
    
    f_int64 Raw() const { return v; }

    inline void shiftr(f_int32 y)
    {    v >>= y; }
    
    inline void shiftl(f_int32 y)
    {    v <<= y; }

    inline bool operator<(const Fixed32& other) const {
        return v < other.v;
    }

    inline bool operator>(const Fixed32& other) const {
        return v > other.v;
    }
    
    Fixed32 operator-() const {
        return Fixed32::FromRaw(-v);
    }
#ifdef IOSTREAMS
    friend std::ostream& operator<<(std::ostream& os, const Fixed32&);

    static void testharness();
#endif
private:
    f_int64 v;
};


Fixed32 operator*(const Fixed32& a, const Fixed32& b );

Fixed32 reciprocal(const Fixed32& x);

/*!\brief Divide two Fixed32 objects

*/
inline Fixed32 operator/(const Fixed32& a, const Fixed32& b ) {
#ifdef IOSTREAMS
//    cout << "Fixed32::operator/(" << a << "," << b << ")" << endl;
#endif
    return a * reciprocal(b);
}

template<class T> inline Fixed32 operator/(const Fixed32& a, const T& b ) {
    return a / Fixed32(b);
}

inline Fixed32 operator+(const Fixed32& a, const Fixed32& b ) {
#ifdef IOSTREAMS
//    cout << "Fixed32::operator+(" << a << "," << b << ")" << endl;
#endif
    return Fixed32::FromRaw(a.Raw() + b.Raw());
}

inline Fixed32 operator-(const Fixed32& a, const Fixed32& b ) {
#ifdef IOSTREAMS
//    cout << "Fixed32::operator-(" << a << "," << b << ")" << endl;
#endif
    return Fixed32::FromRaw(a.Raw() - b.Raw());
}

inline bool operator!=(const Fixed32& a, const Fixed32& b ) {
    return (a.Raw() != b.Raw());
}
inline bool operator==(const Fixed32& a, const Fixed32& b ) {
    return (a.Raw() == b.Raw());
}
inline Fixed32 abs(const Fixed32& f) {
    if (f < Fixed32(int32_t(0)))
        return -f;
        
    return f;
}


/*!\brief Fixed16: A 16.16 fixed point number
*/
class Fixed16 {
public:

    Fixed16() {    v = 0; }
    explicit Fixed16( const f_int32 i )   : v( f_int32(i) << 16 ) {}
    
    Fixed16( const Fixed32& f32 ) {
#ifdef IOSTREAMS
        // test for overflow
        if (f32.toDouble() > 32768.0) {
            cout << "Fixed16 OVERFLOW " << f32 << endl;
            throw -1;
        }
#endif
        f_int64 temp(f32.Raw());
        temp >>= 16;
    
        v = temp.toInt32();
    }
    
    static Fixed16 FromFixed32( const Fixed32& f32 ) {
        f_int64 temp(f32.Raw());
        temp >>= 16;
    
        return Fixed16::FromRaw(temp.toInt32());
    }
    
    static Fixed16 FromRaw( f_int32 raw ) {
        Fixed16 r;
        r.v = raw;
        return r;
    }

    void FromInt( f_int32 i ) {
        v = ( f_int32(i) << 16 );
    }
    
    static Fixed16 zero();
    static Fixed16 one();
    static Fixed16 PRECISION() { return Fixed16::FromRaw(1); }
    static Fixed16 PI();
    static Fixed16 PI_OVER_2();
    static Fixed16 PI_3OVER_2();

    f_int32 Raw() const {
        return v;
    }

    /* See also the round() operation */
    f_int32 toInteger() const {
        return v >> 16;
    }
    
    /* See also the round() operation */
    double toDouble() const {
        double f = (v >> 16) + (double(v & 0xFFFF) / 65536.0);
        return f;
    }
    
    
    Fixed16& operator=( const Fixed16& rhs ) {
        v = rhs.v;
        return *this;
    }
    
    Fixed16& operator=( const f_int32& rhs ) {
        FromInt(rhs);
        return *this;
    }
    
    Fixed16& operator*=( f_int32 rhs ) {
        v *= rhs;
        return *this;
    }
    
    Fixed16& operator+=(const Fixed16& rhs ) {
        v += rhs.v;
        return *this;
    }

    Fixed16& operator-=(const Fixed16& rhs ) {
        v -= rhs.v;
        return *this;
    }

    Fixed16& operator*=(const Fixed16& rhs ) {
        f_int64 temp = f_int64::mult32(v,rhs.v);
        temp >>= 16;
        v = temp.toInt32();
        return *this;
    }

    // Logical operations
    inline bool operator==(const Fixed16& other) const {
        return v == other.v;
    }

    inline bool operator!=(const Fixed16& other) const {
        return v != other.v;
    }

    inline bool operator<(const Fixed16& other) const {
        return v < other.v;
    }

    inline bool operator>(const Fixed16& other) const {
        return v > other.v;
    }

    inline bool operator<=(const Fixed16& other) const {
        return v <= other.v;
    }

    inline bool operator>=(const Fixed16& other) const {
        return v >= other.v;
    }

#ifdef IOSTREAMS
/*    explicit Fixed16(const double x)
    {
        Fixed32 x32(x);
        *this = Fixed16(x32);
    }*/
    
    friend std::ostream& operator<<(std::ostream& os, const Fixed16&);

    static Fixed16 rand(int x);
    static void testharness();
#endif
    
private:
    f_int32 v;
};

//////////////////////////////////////////////////////////////////////////////
//
// Useful mathematical operations for Fixed16 objects
//
//////////////////////////////////////////////////////////////////////////////


inline Fixed16 operator<<(const Fixed16& x, f_int32 y) {
    return Fixed16::FromRaw(x.Raw() << y);
}

inline Fixed16 operator>>(const Fixed16& x, f_int32 y) {
    return Fixed16::FromRaw(x.Raw() >> y);
}

inline Fixed16 operator+(const Fixed16& a, const Fixed16& b ) {
    return Fixed16::FromRaw(a.Raw() + b.Raw());
}

inline Fixed16 operator+(const Fixed16& a, const f_int32& b ) {
     return a + Fixed16(b);
}

inline Fixed32 operator+(const Fixed32& a, const Fixed16& b ) {
    return a + Fixed32(b);
}
inline Fixed32 operator+(const Fixed16& a, const Fixed32& b ) {
    return Fixed32(a) + b;
}

inline Fixed16 operator-(const Fixed16& a, const Fixed16& b ) {
    return Fixed16::FromRaw(a.Raw() - b.Raw());
}

inline Fixed16 operator-(const Fixed16& a, const f_int32& b ) {
    return a - Fixed16(b);
}
inline Fixed32 operator-(const Fixed32& a, const Fixed16& b ) {
    return a - Fixed32(b);
}
inline Fixed32 operator-(const Fixed16& a, const Fixed32& b ) {
    return Fixed32(a) - b;
}


/* The product of two Fixed16's is a Fixed32 */
inline Fixed32 operator*( const Fixed16& a, const Fixed16& b ) {
    return Fixed32::FromRaw(f_int64::mult32(a.Raw(), b.Raw()));
}

inline Fixed32 operator*(const Fixed32& a, const Fixed16& b ) {
#ifdef IOSTREAMS
    double da = a.toDouble();
    double db = b.toDouble();

    if (da * db > 0x7fffffff)
    {
        cout << "OVERFLOW ERROR" << endl;
        throw -1;
    }
//    cout << "Fixed32::operator*(" << a << "," << b << ")" << endl;
#endif
    return Fixed16::FromFixed32(a) * b;
}

inline Fixed32 operator*(const Fixed16& a, const Fixed32& b ) {
    return b*a;
}


inline Fixed32 operator*( const Fixed16& a, const f_int32& b ) {
//    cout << "operator*(" << a << "," << b << ")" << endl;
    if (2 == b)
        return Fixed32::FromRaw(f_int64(a.Raw()) << 17);

    return a * Fixed16(b);
}

// Negation    
inline Fixed16 operator-(const Fixed16& a ) {
//    cout << "operator-(" << a << "," << b << ")" << endl;
    return Fixed16::FromRaw(-a.Raw());
//    return Fixed16::FromFixed32(a * Fixed16(-1));
}

Fixed16 reciprocal(const Fixed16& x);

//#define HIGH_ACCURACY 1

inline Fixed16 operator/( const Fixed16& a, const Fixed16& b ) {
#ifdef HIGH_ACCURACY
    /* HIGH ACCURACY but Slower */
    f_int64 ar = f_int64(a.Raw(),0); // << 32;
    f_int64 br = f_int64(b.Raw());
    f_int64 ret = (ar / br) >> 16;
    return Fixed16::FromRaw(ret.toInt32());
#else    /* Low accuracy and MUCH faster */
    return Fixed16::FromFixed32(a * reciprocal(b));
#endif
}

inline Fixed16 operator/( const Fixed16& a, const f_int32 b ) {
//    cout << "operator/F16int" << endl;
    if (2 == b)
        return a >> 1;

    return a / Fixed16(b);
}

inline bool operator==( const Fixed16& a, const f_int32 b ) {
    return a == Fixed16(b);
}
inline bool operator==(  const f_int32 b, const Fixed16& a) {
    return a == Fixed16(b);
}


inline bool operator<( const Fixed16& a, f_int32 b ) {
    return a < Fixed16(b);
}
inline bool operator<=( const Fixed16& a, f_int32 b ) {
    return a <= Fixed16(b);
}
inline bool operator>( const Fixed16& a, f_int32 b ) {
    return a > Fixed16(b);
}


inline Fixed16 abs(const Fixed16& f) {
    if (f < Fixed16::zero())
        return -f;
        
    return f;
}

Fixed16 sqrt(const Fixed16& x);
Fixed16 invsqrt(const Fixed16& x);
Fixed16 sqrt(const Fixed32& x);

Fixed16 round(const Fixed16& f);

/* Trigonometry */
Fixed16 sin(const Fixed16& f);
Fixed16 cos(const Fixed16& f);
Fixed16 tan(const Fixed16& f);
    
Fixed16 arcsin(const Fixed16& f);
Fixed16 arccos(const Fixed16& f);
Fixed16 arctan(const Fixed16& f);
Fixed16 arctan2(const Fixed16& y , const Fixed16& x);

Fixed16 deg_to_rad(Fixed16 val);
Fixed16 rad_to_deg(Fixed16 val);

#endif /* __Fixed_h__ */
